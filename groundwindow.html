<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Groundwindow2</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body { margin: 0px; overflow: hidden; }
      #viz { position: absolute; top: 0; left: 0; right: 0; bottom: 0; }
      #quantbutton { position: absolute; right:0; top: 0; border: thin red solid; background:#ddf; display: block }
      #quantshow { position: absolute; right:0; top: 0; width: 75%; border: thin red solid; background:#fdd; display: block }
      #quantshowtext { font-size: 200%; position: relative; left: 0; top: 0; display: none }
      #postext { position: relative; left: 0; top: 0; display: block }
      #postext input, #quantbutton input { font-size: 150%}
      #dcamara { position: absolute; left: 0; bottom: 0; width:50%; height:50%; display: none; background: red }
      #camara { width:100%; height:100%;  }
    </style>
    <link rel="manifest" href="manifest.json">
    <script src="three.min.js"></script>
    <script src="DeviceOrientationControls.js?2"></script>
    <script src="plottedgeometry.js"></script>
    <script src="positionfuncs.js"></script>
    <script src="pickingfuncs.js"></script>
    <script src="shaders.js"></script>
  </head>
  <body>
    <div id="main">
      <div id="viz"></div>
      <div id="quantbutton">
        <input type="button" value="Q" id="qshow"/>
        <span id="debugtext"></span>
      </div>
      <div id="quantshow">
        <div id="quantshowtext">TEE</div>
        <div id="postext">
          <div id="numpanel">
              <span id="gpsrec">Dgps</span>
              <span id="gpsrecV">Dgps</span>
              <span id="testout">:</span>
              <span id="testout2">__</span>
          </div>
          <div>
              <input type="button" value="Hop" id="camerahop"/>
              <input type="button" value="Cen" id="reset31"/>
              <input type="button" value="Mag" id="magorientset"/>
              <input type="button" value="See" id="camera"/>
              <input type="button" value="Lab" id="labelsonoff"/>
              <input type="button" value="Top" id="highabove"/>
              <input type="button" value="9999" id="yearcycle"/>
          </div>
        </div>
      </div>
      <div id="dcamara">
        <video id="camara" autoplay controls></video>
      </div>
    </div>
  
  <script>
//function getshader(k) { document.getElementById(k).textContent; };
function getshader(k) { return shaders[k]; };

var svx3d = undefined;   // current cave survey object
var svxviewcurrentgps = { latp0:0, lngp0:0, altp0:0, nyfac:111319.49079327358, nxfac:0, eyfac:0, exfac:111319.49079327358 }; // replacement view when too far from svxview position
var svxview = svxviewcurrentgps; // reset to svx3d if all attributes there; svxviewcurrentgps also rewritten if gps reading comes through so we can project into local space

function reset31(event) 
{
    event.preventDefault(); 
    if (svxview !== svx3d) {
        svxview = svx3d; 
        quantshowshow("Moving GPS origin back to reality"); 
    } else {
        svxview = svxviewcurrentgps; 
        quantshowshow("Moving GPS origin to the caves"); 
    }
    PositionObject.SetCameraPositionG(); 
    quantshowhidedelay(1500); 
    return false; 
}

function HighTopView()
{
    GdeviceOrientation.gamma = 0.1;   // required for alpha to change position
    GdeviceOrientation.beta = 0; 
    GdeviceOrientation.alpha = -90; 
    PositionObject.geosetdirect(PositionObject.gslongitude, PositionObject.gslatitude, PositionObject.gsaltitude + 100, 0, 0);  
}

var camera, scene, renderer, controls, threejselement, vizcontainer;
var quantshowelement, quantshowtextelement, postextelement; 
var clock = new THREE.Clock();
var hoptime = null; 
var hopmode = 0; // 0 on ground, 1 going up, -1 going down, 2 on the up
var linewidth = 3; 
var hopheight = 1500.0; 
function ZhopGo(lhopheight) 
{
    if (hopmode == 0)
        hopheight = lhopheight; 
    hopmode = (hopmode == 0 ? 1 : -1); 
    hoptime = clock.elapsedTime; 
}
function Zhopdisplacement() 
{
    if (hopmode === 0)
        return 0.0; 
    if (hopmode === 2)
        return hopheight; 
    if (hoptime === null)
        return 0.0; 
    var hsecs = clock.elapsedTime - hoptime; 
    if (hsecs > 2) {
        hoptime = null; 
        hopmode = (hopmode == 1 ? 2 : 0); 
        return (hopmode === 2 ? hopheight : 0); 
    }
    var x = Math.abs((hsecs-2)/2); 
    if (hopmode == -1)
        x = 1 - x; 
    var y = (x < 0.5 ? (1 - x*x*2) : (1 - x)*(1 - x)*2); 
    return hopheight*y; 
}





var backgroundscene = null, backgroundcamera = null; 
var videotexture; 
var backgroundvideo = null; 
window.URL = window.URL || window.webkitURL; 
navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia; 
var bshowvideobackground = false; 
function LoadVideoBackground()
{
    if (bshowvideobackground) {
        bshowvideobackground = false; 
        return; 
    }
    if (backgroundscene) {
        bshowvideobackground = true; 
        return; 
    }
        
    backgroundvideo = document.createElement("video"); 
    backgroundvideo.width = vizcontainer.offsetWidth; 
    backgroundvideo.height = vizcontainer.offsetHeight; 
    backgroundvideo.autoplay = true; 
    
    navigator.getUserMedia({"audio":false, "video":true}, function(streamVideo) { 
        backgroundvideo.src = window.URL.createObjectURL(streamVideo); 
        //alert(backgroundvideo.src); 
        videotexture = new THREE.Texture(backgroundvideo); 
        var backgroundmesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2, 0), new THREE.MeshBasicMaterial({map: videotexture})); 
        backgroundmesh.material.depthTest = false; 
        backgroundmesh.material.depthWrite = false; 
        backgroundscene = new THREE.Scene(); 
        backgroundcamera = new THREE.Camera(); 
        backgroundscene.add(backgroundcamera); 
        backgroundscene.add(backgroundmesh); 
        bshowvideobackground = true; 
    }, function() { alert("bad"); }); 
}


function resize() 
{
    var width = vizcontainer.offsetWidth;
    var height = vizcontainer.offsetHeight;
    camera.aspect = width / height;
    PlotGeometryObject.resizeP(width, height); 
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
}

function update(dt) 
{
    resize();
    camera.updateProjectionMatrix();
    controls.update(dt);
}

function render(dt) 
{
    renderer.autoClear = false; 
    renderer.clear(); 
    if (bshowvideobackground && backgroundscene) {
        if (backgroundvideo.readyState === backgroundvideo.HAVE_ENOUGH_DATA) {
            videotexture.needsUpdate = true; 
        }
        renderer.render(backgroundscene, backgroundcamera);
    }
    renderer.render(scene, camera);
}

var yeartimestep = 0; 
function animate(t) 
{
    if (hopmode !== 0)
        camera.position.y = PositionObject.camera3JSAlt + Zhopdisplacement(); 
    //$("#camerapos").text("cam:"+camera.position.x.toFixed(1)+" "+camera.position.y.toFixed(1)+" "+camera.position.z.toFixed(1))
    requestAnimationFrame(animate);
    if  ((touchmovestate == 1) && (clock.elapsedTime - touchtime > 1)) {
        touchmovestate = 5; 
        PickingObject.selecteffort(touchStart.x, touchStart.y, "fromanimate")
    }
    var cd = clock.getDelta(); 
    if (yeartimestep != 0) {
        PlotGeometryObject.centrelinematerial.uniforms.yeartime.value = Math.min(PlotGeometryObject.maxyearvalue+1, Math.max(PlotGeometryObject.minyearvalue, PlotGeometryObject.centrelinematerial.uniforms.yeartime.value + cd*yeartimestep)); 
        document.getElementById("yearcycle").value = PlotGeometryObject.centrelinematerial.uniforms.yeartime.value; 
        if ((PlotGeometryObject.centrelinematerial.uniforms.yeartime.value >= PlotGeometryObject.maxyearvalue+1) && (yeartimestep > 0))
            yeartimestep = 0; 
    }
    
    update(cd);
    render(cd);
}

function tryabsoluteorient(event)
{
    window.removeEventListener('absolutedeviceorientation', tryabsoluteorient);  
    quantshowshow("**"); 
    console.log("absoluteorient", event); 
    quantshowtextelement.textContent = "gting "+event.alpha.toFixed(1)+" "+event.absolute; 
    if ((event.alpha !== null) && event.absolute) {
        controls.alphaoffset = event.alpha - GdeviceOrientation.alpha; // GdeviceOrientation is global var accessing deviceOrientation within the controls library
        quantshowtextelement.textContent = "AA-offs: "+controls.alphaoffset.toFixed(1); 
    }
    quantshowhidedelay(1500); 
}

var quantshowhidetimeout = null; 
function quantshowhide()  
{
    quantshowelement.style.display = "none";  
    if (quantshowhidetimeout !== null) {
        clearTimeout(quantshowhidetimeout);  
        quantshowhidetimeout = null; 
    }
}

function quantshowhidedelay(dt)  { if (quantshowhidetimeout === null)  quantshowhidetimeout = setTimeout(quantshowhide, dt);  }
function quantshowshow(qtext)  
{ 
    if (quantshowhidetimeout !== null) {
        clearTimeout(quantshowhidetimeout);  
        quantshowhidetimeout = null; 
    }
    quantshowelement.style.display = "block"; 
    if (qtext) {
        quantshowtextelement.textContent = qtext; 
        quantshowtextelement.style.display = "block"; 
        postextelement.style.display = "none"; 
    } else {
        quantshowtextelement.style.display = "none"; 
        postextelement.style.display = "block"; 
    }
}



var touchStart = new THREE.Vector2(), touchEnd = new THREE.Vector2(), touchDelta = new THREE.Vector2();
var alphaoffsetStart, touchtime; 
var touchmovestate = 0; // 1 is touchdrag, 2 is dragging left-right for alpha compass rotate, 3 for depth of fogbrightness, 4 pinch for FOV change, 5 for point selection
function touchstartfunc(event) 
{
    event.stopPropagation(); 
    touchtime = clock.elapsedTime; 
    if (event.touches.length == 1) {
        touchStart.set(event.touches[0].pageX, event.touches[0].pageY); 
        touchmovestate = 1; // pre-single move, but don't know direction of drag
    } else if ((event.touches.length == 2) && (touchmovestate <= 1)) {
        touchStart.set(event.touches[1].pageX - event.touches[0].pageX, event.touches[1].pageX - event.touches[0].pageY); 
        touchmovevalueStart = camera.fov; 
        quantshowshow("**"); 
        touchmovestate = 4; 
    }
}


function touchholdfunc(event) 
{ 
    event.preventDefault(); 
    event.stopPropagation(); 
    if (touchmovestate == 1) {
        touchmovestate = 5; 
        PickingObject.selecteffort(event.pageX, event.pageY, "contextevent"); 
    }
    return false 
}; 

function touchmovefunc(event)
{
    event.preventDefault(); 
    event.stopPropagation(); 
    var touchmovepixelsrequired = 20; 
    if (event.touches.length == 1) {
        touchEnd.set(event.touches[0].pageX, event.touches[0].pageY);
        touchDelta.subVectors(touchEnd, touchStart); 
        if ((touchmovestate == 1) && (Math.max(Math.abs(touchDelta.x), Math.abs(touchDelta.y)*2) > touchmovepixelsrequired)) {
            touchmovestate = (Math.abs(touchDelta.x) >= Math.abs(touchDelta.y) ? 2 : 3); 
            touchmovevalueStart = (touchmovestate == 2 ? controls.alphaoffset : PlotGeometryObject.centrelinematerial.uniforms.closedist.value); 
            quantshowshow("**");   // drops through
            //if (touchmovestate == 2)
            //    controls.alphalock = true; 
        }
        if  ((touchmovestate == 1) && (clock.elapsedTime - touchtime > 1)) {
            touchmovestate = 5; 
            PickingObject.selecteffort(touchStart.x, touchStart.y, "touchholdmove")
        }

        if (touchmovestate == 2) {
            //controls.alpha += THREE.Math.degToRad(touchDelta.x*0.1);  // didnt work
            //touchStart.set(touchEnd.x, touchEnd.y); // make incremental so the holding flag within the controls can also work
            controls.alphaoffset = touchmovevalueStart + touchDelta.x*0.3;  
            quantshowtextelement.textContent = "A-offs: "+controls.alphaoffset.toFixed(0); 
        } else if (touchmovestate == 3) {
            PlotGeometryObject.setclosedistvalueP(Math.max(0.0, touchmovevalueStart - Math.max(1.0, touchmovevalueStart)*touchDelta.y*(touchDelta.y < 0 ? 0.02 : 0.005))); 
            quantshowtextelement.textContent = "Light: "+(PlotGeometryObject.centrelinematerial.uniforms.closedist.value).toFixed(0)+"m"; 
        }
    } else if (event.touches.length == 2) {
        if (touchmovestate == 4) {
            touchEnd.set(event.touches[1].pageX - event.touches[0].pageX, event.touches[1].pageX - event.touches[0].pageY); 
            camera.fov = Math.min(175.0, Math.max(1.0, touchmovevalueStart*(touchStart.length()/touchEnd.length()))); 
            quantshowtextelement.textContent = "FOV: "+camera.fov.toFixed(0)+"deg"; 
        }
    }
    return false; 
}

function touchendfunc(event)
{
    event.preventDefault(); 
    //if (touchmovestate == 2)
    //    controls.alphalock = false; 
    if (touchmovestate > 0)
        quantshowhidedelay(1500); 
    touchmovestate = 0; 
}

var accthresh = 6.0; 
var sumaccz = 0.0; 
var isumaccz = 0; 
var hopsuppresstime = 0.0; 
var maxaccz = 0; 
function devorientationevent(event)
{
    if (event.acceleration.z > accthresh) {
        if (event.acceleration.z > maxaccz) {
            maxaccz = event.acceleration.z; 
        }
    } else if (event.acceleration.z < -accthresh) {
        if (event.acceleration.z < maxaccz) {
            maxaccz = event.acceleration.z; 
        }
    } else {
        if ((maxaccz > 0.0) && (hopmode == 0)) {
            if (hopsuppresstime > clock.elapsedTime) { 
                ZhopGo((maxaccz-5.5)*(maxaccz-5.5)*300); 
                document.getElementById('debugtext').textContent = maxaccz.toFixed(3); 
            }
        } else if (maxaccz < 0.0) {
            if (hopmode == 2) {
                ZhopGo(0); 
            } else {
                hopsuppresstime = clock.elapsedTime + 2; 
            }
        }
        maxaccz = 0.0; 
    }
}


var keylatlngstep = 0.0003; 
var keyaltstep = 10.0; 
function init() 
{
    renderer = new THREE.WebGLRenderer();
    threejselement = renderer.domElement;
    vizcontainer = document.getElementById('viz');
    vizcontainer.appendChild(threejselement);
    quantshowelement = document.getElementById('quantshow'); 
    quantshowtextelement = document.getElementById('quantshowtext'); 
    postextelement = document.getElementById('postext'); 
    
    scene = new THREE.Scene();
    PlotGeometryObject.scene = scene; 
    var fieldofview = 30; // degrees (smaller is more tunnel like)
    var aspect = 1;       // reset in resize()
    var neardistance = 5; 
    var fardistance = 70000; 
    camera = new THREE.PerspectiveCamera(fieldofview, aspect, neardistance, fardistance);
    camera.position.set(0, 0, 0); 
    scene.add(camera); 

    controls = new THREE.DeviceOrientationControls(camera, true);
    controls.connect();
    controls.update();
    window.addEventListener('keydown', function(event) { 
        var mv = { }; 
        if (event.keyCode == 37)       mv[event.shiftKey ? "x" : "rx"] = -1;   // left cursor
        else if (event.keyCode == 39)  mv[event.shiftKey ? "x" : "rx"] = 1;    // right cursor
        else if (event.keyCode == 38)  mv[event.shiftKey ? "z" : "rz"] = 1;    // up cursor
        else if (event.keyCode == 40)  mv[event.shiftKey ? "z" : "rz"] = -1;   // down cursor
        else if (event.keyCode == 33)  mv[event.shiftKey ? "y" : "ry"] = 1;    // page up
        else if (event.keyCode == 34)  mv[event.shiftKey ? "y" : "ry"] = -1;   // page down
        if (mv.rx || mv.ry || mv.rz)  {
            if (mv.rx)  GdeviceOrientation.gamma += mv.rx*5; 
            if (mv.rz)  GdeviceOrientation.beta += mv.rz*5; 
            if (mv.ry)  GdeviceOrientation.alpha += mv.ry*5; 
        } else if (mv.x || mv.y || mv.z) {
            PositionObject.geosetdirect(PositionObject.gslongitude + (mv.x|0)*keylatlngstep, PositionObject.gslatitude + (mv.z|0)*keylatlngstep, PositionObject.gsaltitude + (mv.y|0)*keyaltstep, 0, 0);  
            document.getElementById('gpsrec').textContent = "FLat:"+PositionObject.gslatitude.toFixed(7)+" Lng:"+PositionObject.gslongitude.toFixed(7)+" Alt:"+PositionObject.gsaltitude.toFixed(1); 
       }
    });

    
    var light = new THREE.PointLight(0xffffff);
    light.position.set(0, 2500, 0);
    scene.add(light);

    PlotGeometryObject.LoadPassageTubesP(svx3d.passagexcsseq, svx3d.passagexcs, 1.0/svx3d.scale); // before centrelines because they overwrite in the depth buffer
    PlotGeometryObject.LoadMountains(svx3d.landmarks, 1.0/svx3d.scale); 
    PlotGeometryObject.LoadCentrelines(svx3d.legnodes, svx3d.legindexes, 1.0/svx3d.scale); 
    //PlotGeometryObject.LoadEntrances(svx3d.entrances, 1.0/svx3d.scale); 
    PlotGeometryObject.setredalts(PlotGeometryObject.redalt, PlotGeometryObject.vfac); 
 
    PositionObject.LoadTrail(scene); 
    //PositionObject.LoadTrailRods(scene); 
    

    PositionObject.LoadFootpos(scene); 
    //PositionObject.LoadPickPos(scene); 
    //LoadVideoBackground(); 

    
    scene.fog = new THREE.Fog(0x202020, 10, 20000);  // near and far
        
    document.getElementById("camerahop").addEventListener("click", function() { ZhopGo(1500); }); 
    document.getElementById("reset31").addEventListener("click", reset31); 
    document.getElementById("camera").addEventListener("click", LoadVideoBackground); 
    document.getElementById("magorientset").addEventListener("click", function(event) { event.preventDefault(); window.addEventListener('absolutedeviceorientation', tryabsoluteorient); }); 
    document.getElementById("highabove").addEventListener("click", HighTopView); 
    
    
    document.getElementById("labelsonoff").addEventListener("click", function(event) { entlabelscard.visible = !entlabelscard.visible; PositionObject.footposmesh.visible = !PositionObject.footposmesh.visible; }); 
    document.getElementById("yearcycle").addEventListener("click", function(event) { yeartimestep = (yeartimestep == -1.0 ? 1.0 : -1.0); }); 

    quantshowelement.addEventListener("click", quantshowhide, true); // so that the preventdefault stops it hiding
    document.getElementById("qshow").addEventListener("click", function(event) { quantshowshow(false); }); 

    vizcontainer.addEventListener('touchstart', touchstartfunc, false);
    vizcontainer.addEventListener('touchend', touchendfunc, false);
    vizcontainer.addEventListener('touchcancel', touchendfunc, false);
    vizcontainer.addEventListener('touchmove', touchmovefunc, false);
    vizcontainer.addEventListener('contextmenu', touchholdfunc, false); 

    window.addEventListener('resize', resize);
    window.addEventListener('devicemotion', devorientationevent, false);

    setTimeout(resize, 1);
}

var script = document.createElement('script');
//script.setAttribute('src', 'maxpleasure2.js');
script.setAttribute('src', 'test.js');
//script.setAttribute('src', 'erin2.js');
script.setAttribute('type', 'text/javascript');
document.getElementsByTagName('head')[0].appendChild(script);

// callbackgrom the javascript include file above
function LoadSvx3d(lsvx3d)
{
    svx3d = lsvx3d; 
    svx3d.scaleInv = 1.0/svx3d.scale; 

    init();
    if (svx3d.latp0 !== undefined) {
        svxview = svx3d; 
        PositionObject.geosetdirect(svx3d.lngp0, svx3d.latp0, svx3d.altp0, 0, 0);  
    }
    
    animate();
}


// add GPS reader to this or do fake positions
// [must put anonymous functions in here to get this=obect rather than PositionObject.geo_success pointer directly which gets this=Window]
//var watchID = navigator.geolocation.watchPosition(function(p) { PositionObject.geo_success(p); }, function() { PositionObject.geo_error(); }, {enableHighAccuracy:true, timeout:17000, maximumAge:20000}); 
//navigator.geolocation.watchPosition(function(p) { document.getElementById('testout2').textContent = p.coords.altitude; }, function() { document.getElementById('testout2').textContent = "E"; }, {enableHighAccuracy:true, timeout:27000, maximumAge:30000}); 
fakegpsgenerator(); // for desktop use

  </script>
  </body>
</html>

